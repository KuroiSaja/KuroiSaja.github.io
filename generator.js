// =========================
// HELPERS
// =========================

function safeInt(value) {
    if (value === null || value === undefined) return 0;
    if (value === "" || value === "nan") return 0;
    const n = parseInt(value, 10);
    return isNaN(n) ? 0 : n;
}

function safeFormInt(value, minValue = 1) {
    const n = parseInt(value, 10);
    if (isNaN(n) || n < minValue) return null;
    return n;
}

function rawSuroviny(score, hours) {
    return Math.max(score, 0) * hours;
}

function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function concretePerHour(score) {
    if (score < 5) return 0;
    const tier = Math.floor((score - 5) / 5);
    return randomInt(1 + tier, 3 + tier);
}

function splitTags(cell) {
    if (!cell) return new Set();
    return new Set(
        String(cell)
            .toLowerCase()
            .split("|")
            .map(t => t.trim())
            .filter(t => t.length > 0)
    );
}

function weightedRandom(items, weights) {
    const total = weights.reduce((a, b) => a + b, 0);
    let r = Math.random() * total;

    for (let i = 0; i < items.length; i++) {
        r -= weights[i];
        if (r <= 0) {
            return items[i];
        }
    }
    return items[items.length - 1];
}


// =========================
// POOL LOGIC
// =========================

function buildPool(ingredients, environment, season, selectedTags) {
    const pool = [];
    const selectedTagSet = new Set(selectedTags || []);

    for (const row of ingredients) {

        const requiredTags = splitTags(row["required tag"]);
        const forbidTags   = splitTags(row["forbid tag"]);
        const specificTags = splitTags(row["specific tag"]);

        // 1Ô∏è‚É£ required tag ‚Äì absolutn√≠ priorita
        let requiredOk = true;
        for (const tag of requiredTags) {
            if (!selectedTagSet.has(tag)) {
                requiredOk = false;
                break;
            }
        }
        if (!requiredOk) continue;

        // 2Ô∏è‚É£ forbid tag
        for (const tag of forbidTags) {
            if (selectedTagSet.has(tag)) continue;
        }
        if ([...forbidTags].some(t => selectedTagSet.has(t))) continue;
        if (forbidTags.has(environment)) continue;

        // 3Ô∏è‚É£ environment / season
        const envAny = String(row.environment).trim().toLowerCase() === "any";
        let envMatch = envAny || String(row.environment).includes(environment);
        const seasonMatch = String(row.season).includes(season);
        const specificMatch = [...specificTags].some(t => selectedTagSet.has(t));

        // specific + env ‚Üí automaticky v poolu
        if (specificMatch && envMatch && !envAny) {
            pool.push(row);
            continue;
        }

        // specific nahrazuje environment
        if (specificMatch && (envAny || !envMatch)) {
            envMatch = true;
        }

        // 4Ô∏è‚É£ v√°≈æen√° ≈°ance vstupu
        let chance = 0.05;
        if (envMatch && seasonMatch) chance = 1.0;
        else if (envMatch || seasonMatch) chance = 0.30;

        if (Math.random() <= chance) {
            pool.push(row);
        }
    }

    // 5Ô∏è‚É£ fallback ‚Äì min. 3 polo≈æky
    if (pool.length < 3) {
        const needed = 3 - pool.length;

        const fallback = ingredients.filter(row =>
            row.rarity !== "rare" &&
            (
                String(row.environment).trim().toLowerCase() === "any" ||
                String(row.environment).includes(environment)
            )
        );

        const existingNames = new Set(pool.map(r => r.name));
        const candidates = fallback.filter(r => !existingNames.has(r.name));

        while (pool.length < 3 && candidates.length > 0) {
            const idx = Math.floor(Math.random() * candidates.length);
            pool.push(candidates.splice(idx, 1)[0]);
        }
    }

    return pool;
}

// =========================
// PICK LOGIC
// =========================

function pickFromPool(pool, total, selectedTags) {
    const results = [];
    const foundCounts = {};
    const selectedTagSet = new Set(selectedTags || []);

    // Z√°kladn√≠ v√°hy podle rarity
    const RARITY_WEIGHT = {
        common: 1.0,
        uncommon: 0.35,
        rare: 0.12
    };

    // Ladic√≠ konstanty
    const PEAK_STRENGTH = 3.0;
    const THIRD_MULTIPLIER = 1.2;
    const DECAY_RATE = 0.7;
    const SPECIFIC_BOOST = 1.6;

    for (let i = 0; i < total; i++) {
        const weights = [];

        for (const row of pool) {
            const name = row.name;
            const rarity = row.rarity;

            // 1Ô∏è‚É£ base v√°ha podle rarity
            const base = RARITY_WEIGHT[rarity] ?? 0.1;
            let weight = base;

            // 2Ô∏è‚É£ specific tag boost (nejd≈ô√≠v!)
            const specificTags = splitTags(row["specific tag"]);
            for (const tag of specificTags) {
                if (selectedTagSet.has(tag)) {
                    weight *= SPECIFIC_BOOST;
                    break;
                }
            }

            // 3Ô∏è‚É£ opakov√°n√≠
            const count = foundCounts[name] || 0;

            if (count === 1) {
                // 2. n√°lez ‚Äì siln√Ω peak
                weight *= (1 + PEAK_STRENGTH * base);
            } else if (count === 2) {
                // 3. n√°lez ‚Äì st√°le bohat√© m√≠sto
                weight *= THIRD_MULTIPLIER;
            } else if (count >= 3) {
                // √∫tlum od 4.
                weight *= 1.0 / (1 + (count - 2) * DECAY_RATE);
            }

            weights.push(weight);
        }

        // v√°≈æen√Ω v√Ωbƒõr
        const chosen = weightedRandom(pool, weights);
        results.push(chosen);

        foundCounts[chosen.name] = (foundCounts[chosen.name] || 0) + 1;
    }

    return results;
}


// =========================
// GENERATION
// =========================

function generate(ingredients, environment, season, score, hours, critical, criticalFail, selectedTags) {

    const result = {
        inputs: {
            environment,
            season,
            score,
            hours,
            critical,
            criticalFail,
            tags: selectedTags
        },
        raw: rawSuroviny(score, hours),
        ingredients: {}
    };

    // ---- z√°kladn√≠ generace ----
    const pool = buildPool(ingredients, environment, season, selectedTags);
    const totalPicks = concretePerHour(score) * hours;
    const picks = pickFromPool(pool, totalPicks, selectedTags);

    for (const row of picks) {
        const name = row.name;
        if (!result.ingredients[name]) {
            result.ingredients[name] = {
                count: 0,
                type: row.type ?? null,   // üëà TADY JE KL√çƒå
                mana: safeInt(row.mana),
                suroviny: safeInt(row.suroviny),
                usage: row.usage,
                rarity: row.rarity
            };
        }

        result.ingredients[name].count++;
    }

    // ---- kritick√Ω √∫spƒõch ----
    if (critical) {
        const uncommon = ingredients.filter(r => r.rarity === "uncommon");
        const rare = ingredients.filter(r => r.rarity === "rare");

        const choices = [];
        const weights = [];

        // UNCOMMON
        if (uncommon.length > 0) {
            const r = uncommon[Math.floor(Math.random() * uncommon.length)];
            choices.push({
                name: r.name,
                count: 1,
                type: r.type ?? null,
                mana: safeInt(r.mana),
                suroviny: safeInt(r.suroviny),
                usage: r.usage,
                rarity: r.rarity
            });
            weights.push(1.0);
        }

        // RARE (ni≈æ≈°√≠ v√°ha)
        if (rare.length > 0) {
            const r = rare[Math.floor(Math.random() * rare.length)];
            choices.push({
                name: r.name,
                count: 1,
                type: r.type ?? null,
                mana: safeInt(r.mana),
                suroviny: safeInt(r.suroviny),
                usage: r.usage,
                rarity: r.rarity
            });
            weights.push(0.25);
        }

        // ABSTRAKTN√ç MAGICK√ù N√ÅLEZ (MANA)
        const manaMin = Math.max((score - 10) * 5, 5);
        const manaMax = Math.max((score - 5) * 5, manaMin);

        choices.push({
            name: "Abstraktn√≠ magick√Ω n√°lez",
            count: null,
            mana: randomInt(manaMin, manaMax),
            usage: "Volnƒõ vyu≈æiteln√° magick√° energie",
        });
        weights.push(1.0);

        // ABSTRAKTN√ç N√ÅLEZ SUROVIN
        const surovinyMin = Math.max((score - 10) * 10, 10);
        const surovinyMax = Math.max((score - 5) * 10, surovinyMin);

        choices.push({
            name: "Abstraktn√≠ n√°lez surovin",
            count: null,
            suroviny: randomInt(surovinyMin, surovinyMax),
            usage: "Volnƒõ vyu≈æiteln√© alchymistick√© suroviny",
        });
        weights.push(1.0);

        result.rare = weightedRandom(choices, weights);
    }

    // ---- kritick√Ω ne√∫spƒõch ----
    if (criticalFail) {
        result.raw = Math.floor(result.raw / 2);
        for (const item of Object.values(result.ingredients)) {
            item.count = Math.floor(item.count / 2);
        }
    }

    return result;
}




